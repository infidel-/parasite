// NPC AI game state (+ visual and ingame state)
package ai;

import entities.AIEntity;
import _AIState;
import _AIEffectType;
import objects.*;
import game.*;
import const.*;
import particles.*;
import __Math;
import cult.Cult;

class AI extends AIData
{
  static var _ignoredFields = [ 'entity', 'event', 'npc', 'sounds',
  ];
  public var entity: AIEntity; // gui entity
  public var event(get, null): scenario.Event; // event link (for scenario npcs)
  public var npc(get, null): scenario.NPC; // npc link (for scenario npcs)

  var sounds: Map<String, Array<AISound>>; // map of sounds generated by AI

  // history flags
  public var wasAttached: Bool; // was parasite attached to this AI?
  public var wasInvaded: Bool; // was this AI a host at any point?
  public var wasAlerted: Bool; // was this AI alerted at some point?
  public var wasNoticed: Bool; // was this AI seen by parasite after spawning?

  public var x: Int; // grid x,y
  public var y: Int;
  // target x,y when roaming or moving to (resets on state change)
  public var roamTargetX: Int;
  public var roamTargetY: Int;
  // guarding target (for guards)
  public var guardTargetX: Int;
  public var guardTargetY: Int;
  public var direction: Int; // direction of movement

  var _objectsSeen: List<Int>; // list of object IDs this AI has seen
  var _turnsInvisible: Int; // number of turns passed since player saw this AI

  public var state: _AIState; // AI state
  public var stateTime: Int; // turns spent in this state
  public var reason: _AIStateChangeReason; // reason for setting this state
  public var alertness(default, set): Int; // 0-100, how alert is AI to the parasite

  // various AI timers
  public var timers: _AITimers;

  // stats
  public var maxOrgans(get, null): Int; // max amount of organs
  public var maxItems(get, null): Int; // max amount of items in inventory

  // state vars
  public var parasiteAttached: Bool; // is parasite currently attached to this AI

  public function new(g: Game, vx: Int, vy: Int)
    {
      super(g);
      x = vx;
      y = vy;

// will be called by sub-classes
//      init();
//      initPost(false);
    }

// init object before loading/post creation
  public override function init()
    {
      super.init();
      sounds = null;
      roamTargetX = -1;
      roamTargetY = -1;
      guardTargetX = -1;
      guardTargetY = -1;
      state = AI_STATE_IDLE;
      stateTime = 0;
      reason = REASON_NONE;
      alertness = 0;
      timers = {
        alert: 0,
//          alertPlayerNotVisible: 0
      };
      direction = 0;
      parasiteAttached = false;

      wasAttached = false;
      wasInvaded = false;
      wasAlerted = false;
      wasNoticed = false;

      _objectsSeen = new List();
      _turnsInvisible = 0;
      event = null;
      npc = null;
    }

// called after load or creation
  public function initPost(onLoad: Bool)
    {
      sounds = SoundConst.getSounds(soundsID);
      if (onLoad)
        {
          createEntity();
          if (isNPC)
            entity.setNPC();
        }
    }

// called in main post-load
  public function loadPost()
    {
      organs.loadPost();
      skills.loadPost();
      if (npc != null)
        {
          npc.ai = this;
          entity.setNPC();
        }
    }

// show AI graphics
public function show()
  {
    createEntity();
    if (isNPC)
      entity.setNPC();
  }

// hide AI graphics
  public function hide()
    {
      entity = null;
    }

// create entity for this AI
  public function createEntity()
    {
      if (entity != null)
        {
          updateEntity();
          return;
        }

      // select random icon if not set
      if (tileAtlasX == -1 &&
          tileAtlasY == -1 && isHuman)
        {
          var tmp = game.scene.images.getAI(type, isMale);
          tileAtlasX = tmp.x;
          tileAtlasY = tmp.y;
        }
      // legacy: for loading old saves
      // specials were saved as specials[tileAtlasX] index number
      else if (tileAtlasY == -1 && isHuman)
        {
          var specials = (isMale ? Images.specialsMale : Images.specialsFemale);
          var list = specials[type];
          if (!isMale && list == null)
            list = Images.specialsMale[type];
          var row = list[tileAtlasX];
          tileAtlasX = row.x;
          tileAtlasY = row.y;
        }

      // create entity and set correct icon
      entity = new AIEntity(this, game, x, y);
      // blackops heavy kludge
      if (inventory.clothing.id == 'fullBodyArmor')
        entity.isMaleAtlas = true;
      else if (!isMale)
        entity.isMaleAtlas =
          (!isMale && type != 'civilian' &&
           Images.specialsFemale[type] == null);
      if (type == 'dog')
        entity.setIcon('entities', 1, Const.ROW_PARASITE);
      else entity.setIcon(
        (isMale ? 'male' : 'female'),
        tileAtlasX, tileAtlasY);

      updateEntity(); // update icon
    }

// update AI tile to a new one
  public function updateTile(x: Int, y: Int)
    {
      tileAtlasX = x;
      tileAtlasY = y;
      entity.setIcon(
        (isMale ? 'male' : 'female'),
        tileAtlasX, tileAtlasY);
    }


// set position
  public function setPosition(vx: Int, vy: Int, ?force: Bool = false)
    {
      if (game.area.getAI(vx, vy) != null && !force)
        return;

      if (!force && game.player.host != this)
        {
          // frob objects on this position
          var objs = game.area.getObjectsAt(vx, vy);
          for (o in objs)
            {
              // 0 - return false
              // 1 - ok, continue
              var ret = o.frob(false, this);
              if (ret == 0)
                return;
            }
        }
      x = vx;
      y = vy;
      entity.setPosition(x, y);
    }


// internal: change direction at random to the empty space
  public inline function changeRandomDirection()
    {
      direction = game.area.getRandomDirection(x, y);
      if (direction == -1)
        trace('ai at (' + x + ',' + y + '): nowhere to move!');
    }


// does this AI sees this position?
  public function seesPosition(xx: Int, yy: Int): Bool
    {
      // too far away
      var distSqr = Const.distanceSquared(x, y, xx, yy);
      if (distSqr > VIEW_DISTANCE * VIEW_DISTANCE)
        return false;

      // check for visibility
      if (!game.area.isVisible(x, y, xx, yy))
        return false;

      return true;
    }


// is this AI near that spot?
  public inline function isNear(xx: Int, yy: Int): Bool
    {
      return (Math.abs(xx - x) <= 1 && Math.abs(yy - y) <= 1);
    }


// set AI state (plus all vars for this state)
  public function setState(vstate: _AIState, ?vreason: _AIStateChangeReason,
      ?msg: String)
    {
      if (vreason == null)
        vreason = REASON_NONE;

      // AI is already in that state
      if (state == vstate)
        return;

      // stop the chat
      if (game.player.chat.target == this)
        {
          game.player.chat.finish();
          if (vstate == AI_STATE_ALERT)
            log('has become agitated.');
        }
      game.ui.hud.resetState();

//      trace('' + id + ' reason: ' + vreason + ' state:' + vstate);
      state = vstate;
      stateTime = 0;
      reason = vreason;
      if (state == AI_STATE_ALERT)
        {
          // message on first alert
          if (isHuman && vreason != REASON_ATTACH)
            game.goals.complete(GOAL_TUTORIAL_ALERT);

          // clear path
          if (isHuman)
            game.scene.clearPath();

          timers.alert = ALERTED_TIMER;
          wasAlerted = true;
        }
      // reset roam target on going back to idle
      else if (state == AI_STATE_IDLE)
        {
          roamTargetX = -1;
          roamTargetY = -1;
        }

      if (msg != null)
        log(msg);

      onStateChange(); // dynamic event
      if (entity != null) // could despawn in state change hook
        updateEntity(); // update icon
    }


// post alert changes, clamp and change icon
  public function updateEntity()
    {
      // already despawned
      if (entity == null)
        return;

      var alertFrame = Const.FRAME_EMPTY;
      if (state == AI_STATE_ALERT)
        alertFrame = Const.FRAME_ALERTED;
      else if (state == AI_STATE_IDLE ||
          state == AI_STATE_MOVE_TARGET ||
          state == AI_STATE_INVESTIGATE)
        {
          if (alertness > 75)
            alertFrame = Const.FRAME_ALERT3;
          else if (alertness > 50)
            alertFrame = Const.FRAME_ALERT2;
          else if (alertness > 0)
            alertFrame = Const.FRAME_ALERT1;
        }

      // panic state
      if (effects.has(EFFECT_PANIC))
        alertFrame = Const.FRAME_PANIC;

      // calling
      if (game.managerArea.hasAI(this, AREAEVENT_CALL_LAW) ||
          game.managerArea.hasAI(this, AREAEVENT_CALL_BACKUP) ||
          game.managerArea.hasAI(this, AREAEVENT_CALL_TEAM_BACKUP))
        alertFrame = Const.FRAME_CALLING;

      // paralysis state
      if (effects.has(EFFECT_PARALYSIS))
        alertFrame = Const.FRAME_PARALYSIS;
      else if (effects.has(EFFECT_SLIME))
        alertFrame = Const.FRAME_SLIME;

      entity.setAlert(alertFrame);
    }


// ===================================  LOGIC  =======================================


// logic: roam around (default)
  function logicRoam()
    {
      // roam target set, move to it
      if (roamTargetX >= 0 && roamTargetY >= 0)
        {
          logicMoveTo(roamTargetX, roamTargetY);
          return;
        }

      if (Math.random() < 0.2)
        changeRandomDirection();

      // nowhere to move - should be a bug
      if (direction == -1)
        return;

      var nx = x + Const.dirx[direction];
      var ny = y + Const.diry[direction];
      var ok =
        (game.area.isWalkable(nx, ny) &&
         !game.area.hasAI(nx, ny) &&
         !(game.playerArea.x == nx && game.playerArea.y == ny));
      if (!ok)
        {
          changeRandomDirection();
          return;
        }
      else setPosition(nx, ny);
    }


// logic: run away from this x,y
  function logicRunAwayFrom(xx: Int, yy: Int)
    {
      // form a temp list of dirs that have empty tiles and are as far away
      // from threat as possible
      var tmp = [];
      for (i in 0...Const.dirx.length)
        {
          var nx = x + Const.dirx[i];
          var ny = y + Const.diry[i];
          var ok = (
            game.area.isWalkable(nx, ny) && !game.area.hasAI(nx, ny) &&
              (Math.abs(nx - game.playerArea.x) >= Math.abs(x - game.playerArea.x) &&
               Math.abs(ny - game.playerArea.y) >= Math.abs(y - game.playerArea.y))
            );
          if (ok)
            tmp.push(i);
        }

      // nowhere to run
      if (tmp.length == 0)
        {
          if (Std.random(100) < 30)
            log('cowers in panic!');
          return;
        }

      direction = tmp[Std.random(tmp.length)];
//      trace('tmp: ' + tmp + ' ai at (' + x + ',' + y + '): dir: ' + direction +
//        ' n:' + (x + Const.dirx[direction]) + ',' + (y + Const.diry[direction]));

      var nx = x + Const.dirx[direction];
      var ny = y + Const.diry[direction];
      setPosition(nx, ny);
    }


// logic: try to tear parasite away
  function logicTearParasiteAway()
    {
      log('tries to tear you away!');

      game.playerArea.attachHold -= strength;
      if (game.playerArea.attachHold > 0)
        return;

      parasiteAttached = false;
      entity.setMask(-1);
      log('manages to tear you away.');
      game.playerArea.onDetach(); // notify player
    }


// common logic: move to x,y
  public function logicMoveTo(x2: Int, y2: Int)
    {
      // get path
      var path = game.area.getPath(x, y, x2, y2);
      if (path == null)
        return;

      setPosition(path[0].x, path[0].y);
    }


// logic: attack player
  function logicAttack()
    {
      // get current weapon
      var item = inventory.getFirstWeapon();
      var info = null;

      // use animal attack
      if (!isHuman)
        info = ItemsConst.animal;
      // use fists
      else if (item == null)
        info = ItemsConst.fists;
      else info = item.info;
      var weapon = info.weapon;

      // check for distance on melee
      if (!weapon.isRanged &&
          !isNear(game.playerArea.x, game.playerArea.y))
        {
          logicMoveTo(game.playerArea.x, game.playerArea.y);
          return;
        }

      // parasite attached to human, do not shoot (blackops are fine)
      if (isHuman &&
          game.player.state == PLR_STATE_ATTACHED &&
          game.playerArea.attachHost.isHuman &&
          type != 'blackops')
        {
          if (Std.random(100) < 30)
            {
              log('hesitates to attack you.');
              emitSound({
                text: 'Shit!',
                radius: 5,
                alertness: 10
              });
              return;
            }
        }

      // play weapon sound
      if (weapon.sound != null)
        emitSound(weapon.sound);

      // weapon skill level (ai + parasite bonus)
      var roll = __Math.skill({
        id: weapon.skill,
        // hardcoded animal attack skill level
        level: skills.getLevel(weapon.skill),
      });

      // draw attack effect
      if (weapon.isRanged)
        Particle.createShot(
          weapon.sound.file, game.scene, x, y,
          game.playerArea, roll);

      // roll skill
      if (!roll)
        {
          log('tries to ' + weapon.verb1 + ' you, but misses.');
          return;
        }

      // stun damage
      // when player has a host, stuns the host
      // when player is a parasite, just do regular damage
      if (weapon.type == WEAPON_STUN &&
          game.player.state == PLR_STATE_HOST)
        {
          var mods: Array<_DamageBonus> = [];

          // protective cover
          if (game.player.state == PLR_STATE_HOST)
            {
              var o = game.player.host.organs.get(IMP_PROT_COVER);
              if (o != null)
                mods.push({
                  name: 'protective cover',
                  val: - Std.int(o.params.armor)
                });
            }

          var roll = __Math.damage({
            name: 'STUN AI->player',
            min: weapon.minDamage,
            max: weapon.maxDamage,
            mods: mods
          });

          var resist = __Math.opposingAttr(
            game.player.host.constitution, roll, 'con/stun');
          if (resist)
            roll = Std.int(roll / 2);
          if (game.config.extendedInfo)
            game.info('stun for ' + roll + ' rounds, -' + (roll * 2) +
              ' control.');
          game.player.hostControl -= roll * 2;

          log(weapon.verb2 + ' your host for ' + roll +
            " rounds. You're losing control.");

          game.player.host.onEffect({
            type: EFFECT_PARALYSIS,
            points: roll,
            isTimer: true
          });

          game.playerArea.onDamage(0); // on damage event
        }

      // normal damage
      else
        {
          var mods: Array<_DamageBonus> = [];
          // all melee weapons have damage bonus
          if (!weapon.isRanged && weapon.type == WEAPON_BLUNT)
            mods.push({
              name: 'melee 0.5xSTR',
              min: 0,
              max: Std.int(strength / 2)
            });

          // protective cover
          if (game.player.state == PLR_STATE_HOST)
            {
              var o = game.player.host.organs.get(IMP_PROT_COVER);
              if (o != null)
                mods.push({
                  name: 'protective cover',
                  val: - Std.int(o.params.armor)
                });

              // armor
              var clothing = game.player.host.inventory.clothing.info;
              if (clothing.armor.damage != 0)
                mods.push({
                  name: clothing.name,
                  val: - clothing.armor.damage
                });
            }

          var damage = __Math.damage({
            name: 'AI->player',
            min: weapon.minDamage,
            max: weapon.maxDamage,
            mods: mods
          });

          log(weapon.verb2 + ' ' +
            (game.player.state == PLR_STATE_HOST ? 'your host' : 'you') +
            ' for ' + damage + ' damage.');

          game.playerArea.onDamage(damage); // on damage event
        }
    }


// ===============================  LOGIC =============================


// state: move to target spot
  function stateMoveTarget()
    {
      // basic AI vision
      visionIdle();

      // stand and wonder what happened until alertness goes down
      if (alertness > 0)
        return;

      logicMoveTo(roamTargetX, roamTargetY);
      if (x != roamTargetX || y != roamTargetY)
        return;
      // spot reached, idling
      roamTargetY = -1;
      roamTargetY = -1;
      setState(AI_STATE_IDLE);
    }

// state: investigate (move to target spot ignoring alertness)
  function stateInvestigate()
    {
      // basic AI vision
      visionIdle();

      logicMoveTo(roamTargetX, roamTargetY);
      if (x != roamTargetX || y != roamTargetY)
        return;
      // spot reached, idling
      roamTargetY = -1;
      roamTargetY = -1;
      setState(AI_STATE_IDLE);
    }

// state: default alert state handling
  function stateAlert()
    {
      // NOTE: must be first check in this function
      // parasite attached - try to tear it away
      if (parasiteAttached)
        {
          if (!isAgreeable())
            logicTearParasiteAway();
          return;
        }

      // alerted timer update
      if (!game.player.vars.invisibilityEnabled &&
          seesPosition(game.playerArea.x, game.playerArea.y))
        timers.alert = ALERTED_TIMER;
      else timers.alert--;

      // AI calms down
      // relentless AI cannot calm down once alerted
      if (timers.alert == 0 && !isRelentless)
        {
          // guard must return to guard spot
          if (isGuard &&
              (x != guardTargetX || y != guardTargetY))
            {
              setState(AI_STATE_MOVE_TARGET);
              roamTargetX = guardTargetX;
              roamTargetY = guardTargetY;
            }
          // otherwise become idle
          else setState(AI_STATE_IDLE);
          alertness = 10;
          return;
        }

      // aggressive AI - attack player if he is near or search for him
      // same for berserk effect
      if (isAggressive ||
          effects.has(EFFECT_BERSERK))
        {
          if (!game.player.vars.invisibilityEnabled)
            {
              // search for player
              // we cheat a little and follow invisible player
              // before alert timer ends
              if (!seesPosition(game.playerArea.x, game.playerArea.y))
                logicMoveTo(game.playerArea.x, game.playerArea.y);

              // try to attack
              else logicAttack();
            }
        }

      // not aggressive AI - try to run away
      else logicRunAwayFrom(game.playerArea.x, game.playerArea.y);
    }


// state: host logic
  function stateHost()
    {
      // non-assimilated hosts emit random sounds
      if (!hasTrait(TRAIT_ASSIMILATED))
        emitRandomSound('' + AI_STATE_HOST,
          Std.int((100 - game.player.hostControl) / 3));

      // effect: cannot tear parasite away (given right after invasion)
      if (effects.has(EFFECT_CANNOT_TEAR_AWAY))
        return;

      // random: try to tear parasite away
      if (game.player.hostControl < 25 && Std.random(100) < 5)
        {
          log('manages to tear you away.');
          onDetach('default');
          game.playerArea.onDetach(); // notify player
        }
    }

// returns true if player has both affinity and consent
  public inline function isAgreeable(): Bool
    {
      return (affinity >= 100 && chat.consent >= 100);
    }

// TODO: REMOVE
// AI vision: called in idle and movement to target states
  function visionIdle()
    {
      // full affinity + consent results in ignore
      if (isAgreeable())
        alertness -= 5;
      // player visibility
      else if (!game.player.vars.invisibilityEnabled &&
          seesPosition(game.playerArea.x, game.playerArea.y))
        {
          var distance = game.playerArea.distance(x, y);
          var baseAlertness = 3;
          var alertnessBonus = 0;

          // if player is on a host, check for organs
          if (game.player.state == PLR_STATE_HOST)
            {
              // organ: camouflage layer
              var params = EvolutionConst.getParams(IMP_CAMO_LAYER, 0);
              var o = organs.get(IMP_CAMO_LAYER);
              if (o != null)
                baseAlertness = o.params.alertness;
              else baseAlertness = params.alertness;

              // organ: protective cover
              var params = EvolutionConst.getParams(IMP_PROT_COVER, 0);
              var o = organs.get(IMP_PROT_COVER);
              if (o != null)
                alertnessBonus += o.params.alertness;
              else alertnessBonus += params.alertness;
            }
          alertness += Std.int(baseAlertness * (VIEW_DISTANCE + 1 - distance)) +
            alertnessBonus;
          game.profile.addPediaArticle('npcAlertness');
        }
      else alertness -= 5;

      // AI has become alerted
      if (alertness >= 100)
        {
          var reason = REASON_PARASITE;

          if (game.player.state == PLR_STATE_HOST &&
              game.player.host.isHuman)
            reason = REASON_HOST;

          setState(AI_STATE_ALERT, reason);
          return;
        }

      // get all objects that this AI sees
      var tmp = game.area.getObjectsInRadius(x, y, VIEW_DISTANCE, true);

      for (obj in tmp)
        {
          // not a body
          if (obj.type != 'body')
            continue;

          // object already seen by this AI
          if (Lambda.has(_objectsSeen, obj.id))
            continue;

          var body: BodyObject = cast obj;

          // human AI becomes alert on seeing human bodies
          if (isHuman && body.isHumanBody)
            {
              if (!body.wasSeen)
                {
                  // mark body as seen by someone to limit the law response
                  body.wasSeen = true;

                  setState(AI_STATE_ALERT, REASON_BODY);
                }

              // silent alert - no calling law
              else setState(AI_STATE_ALERT, REASON_BODY_SILENT);
            }

          _objectsSeen.add(obj.id);
        }
    }


// checks if this AI should be despawned
// AI despawns when player has not seen it for X turns in a row and its state is idle
  public function checkDespawn()
    {
      // should be in idle state and calmed down
      if (state != AI_STATE_IDLE ||
          (state == AI_STATE_IDLE && alertness > 25))
        {
          _turnsInvisible = 0;
          return;
        }

      // should be invisible to player
      var isVisible = game.area.isVisible(game.playerArea.x, game.playerArea.y, x, y);
      if (isVisible)
        {
          _turnsInvisible = 0;
          return;
        }

      _turnsInvisible++;

      // remove from area
      // guards do not despawn
      if (!isGuard && _turnsInvisible > DESPAWN_TIMER)
        game.area.removeAI(this);
    }


// logic: slime
  function effectSlime()
    {
      var free = effects.decrease(EFFECT_SLIME, strength);
      if (free)
        log('manages to get free of the mucus.');
      else log('desperately tries to get free of the mucus.');

      // set alerted state
      if (state == AI_STATE_IDLE)
        setState(AI_STATE_ALERT, REASON_DAMAGE);

      emitRandomSound('' + REASON_DAMAGE, 30); // emit random sound
    }

// turn for chat timers (can be called in region mode)
  public function chatTurn(time: Int)
    {
      // chat restoring
      if (chat.timeout > 0)
        {
          chat.timeout -= time;
          if (chat.timeout < 0)
            chat.timeout = 0;
          if (chat.consent < 100)
            {
              chat.consent -= time + Std.random(3);
              if (chat.consent < 0)
                chat.consent = 0;
            }
        }
    }

// call AI logic
  public function turn()
    {
      chatTurn(1); // time passing for chat
      stateTime++; // time spent in this state
      if (entity != null)
        entity.turn(); // time passing for entity
      effects.turn(1); // time passing for effects

      // effect: slime, does not allow movement
      if (effects.has(EFFECT_SLIME))
        effectSlime();

      // effect: paralysis
      else if (effects.has(EFFECT_PARALYSIS))
        1;

      // effect: panic, run away
      else if (effects.has(EFFECT_PANIC))
        {
          if (parasiteAttached)
            logicTearParasiteAway();
          else logicRunAwayFrom(game.playerArea.x, game.playerArea.y);
        }

      // preserved - do nothing
      else if (state == AI_STATE_PRESERVED)
        1;

      // idle - roam around or guard, etc
      else if (state == AI_STATE_IDLE)
        DefaultLogic.stateIdle(this);

      // AI alerted - try to run away or attack
      else if (state == AI_STATE_ALERT)
        stateAlert();

      // controlled by parasite
      else if (state == AI_STATE_HOST)
        stateHost();

      // move to target x,y
      else if (state == AI_STATE_MOVE_TARGET)
        stateMoveTarget();

      // investigate
      else if (state == AI_STATE_INVESTIGATE)
        stateInvestigate();

      // post-detach
      else if (state == AI_STATE_POST_DETACH &&
          stateTime >= 2)
        {
          if (isAgreeable())
            setState(AI_STATE_IDLE);
          else setState(AI_STATE_ALERT, REASON_DETACH);
        }

      // post-detach with false memories
      else if (state == AI_STATE_POST_DETACH_MEMORIES &&
          stateTime >= 2)
        setState(AI_STATE_IDLE);

      updateEntity(); // clamp and change entity icons
      checkDespawn(); // check for this AI to despawn

      // emit random sound if it exists
      // assimilated hosts do not emit random sounds
      if (effects.has(EFFECT_CRYING))
        emitRandomSound('' + EFFECT_CRYING, 30);
      if (state != AI_STATE_HOST ||
          !hasTrait(TRAIT_ASSIMILATED))
        emitRandomSound('' + state, 20);
    }

// emit random sound for this key
  public function emitRandomSound(key: String, ?chance: Int = 100)
    {
      var array = sounds[key];
      if (array == null)
        return;

      if (Std.random(100) > chance) // base chance of emitting sound
        return;

      var idx = Std.random(array.length);
      var sound = array[idx];

      emitSound(sound);
    }


// emit specific sound (both visual and audio if it exists)
// also handle sound propagation here
  public function emitSound(sound: AISound)
    {
      // check for min alertness
      if (state == AI_STATE_IDLE &&
          sound.params != null &&
          sound.params.minAlertness != null &&
          alertness < sound.params.minAlertness)
        return;

      // check if AI is visible
      if (!game.area.inVisibleRect(x, y))
        return;

      if (sound.text != '' &&
          sound.text != null &&
          entity != null)
        entity.setText(sound.text, 2);
      if (sound.file != null)
        {
          var file = sound.file;
          if (isHuman && !isMale && file.indexOf('male') == 0)
            file = 'fe' + file;
          var opts: _SoundOptions = {
            x: x,
            y: y,
            canDelay: true,
            // attack sounds always play
            always: (file.indexOf('attack') == 0),
          };
          game.scene.sounds.play(file, opts);
        }
      if (sound.radius <= 0 || sound.alertness <= 0)
        return;

      // get a list of AIs in that radius without los checks and give alertness bonus
      var list = game.area.getAIinRadius(x, y, sound.radius, false);
      for (ai in list)
        if (ai.state == AI_STATE_IDLE ||
            ai.state == AI_STATE_MOVE_TARGET)
          {
//            trace('' + ai.id + ' ' + ai,type + ' alert ' + ai.alertness + ' +' + sound.alertness);
            ai.alertness += sound.alertness;
          }
    }

// ============================ EVENTS ===============================


// event: AI receives damage
  public function onDamage(damage: Int)
    {
      organs.onDamage(damage); // propagate event to organs
      health -= damage;
      if (health == 0) // AI death
        {
          die();

          return;
        }

      // set alerted state
      if (state == AI_STATE_IDLE)
        setState(AI_STATE_ALERT, REASON_DAMAGE);

      emitRandomSound('' + REASON_DAMAGE, 30); // emit random sound
    }


// AI death in the sewers
  public function dieRegion()
    {
      // dying sound
      var array = sounds['' + AI_STATE_DEAD];
      if (array == null)
        return;
      var idx = Std.random(array.length);
      var sound = array[idx];
      var file = sound.file;
      if (isHuman && !isMale && file.indexOf('male') == 0)
        file = 'fe' + file;
      game.scene.sounds.play(file);

      // event stuff
      if (npc != null)
        {
          npc.isDead = true;
          npc.statusKnown = true;
        }
    }


// AI death
  public function die()
    {
      // AI already dead from another call
      if (state == AI_STATE_DEAD)
        return;

      // dying sound
      emitRandomSound('' + AI_STATE_DEAD);

      game.debug('AI.die[' + id + ']');
      if (game.player.state != PLR_STATE_HOST ||
          game.player.host != this)
        log('dies.');
      setState(AI_STATE_DEAD);
      game.area.removeAI(this);
      onDeath(); // event hook
      var o = new BodyObject(game, game.area.id, x, y, type);

      // decay acceleration
      var organ = organs.getActive(IMP_DECAY_ACCEL);
      if (organ != null)
        {
          o.setDecay(organ.params.turns);
          o.isDecayAccel = true;
        }

      o.organPoints = organs.getPoints();
      o.inventory = inventory; // copy inventory
      game.scene.updateCamera();

      // event stuff
      if (npc != null)
        {
          npc.isDead = true;
          npc.statusKnown = true;
        }
    }


// event: parasite attached to this host
  public inline function onAttach()
    {
      // set AI state
      parasiteAttached = true;
      wasAttached = true; // mark as touched by parasite
      setState(AI_STATE_ALERT, REASON_ATTACH);
      updateMask(Const.FRAME_MASK_ATTACHED);
    }

  public function updateMask(x: Int)
    {
      entity.setMask(x);
    }

// event: parasite invaded this host
  public inline function onInvadeWrapped()
    {
      setState(AI_STATE_HOST);
      parasiteAttached = false;
      wasInvaded = true; // mark as invaded
      updateMask(Const.FRAME_MASK_CONTROL);

      // add effect marker so that AI can't tear parasite away
      onEffect({
        type: EFFECT_CANNOT_TEAR_AWAY,
        points: 5,
        isTimer: true
      });
      onInvade(); // type-specific hook
    }


// event: parasite detach from this host
  public inline function onDetach(src: String)
    {
      if (src == 'default')
        setState(AI_STATE_POST_DETACH, null, 'feels groggy and confused.');
      else if (src == 'panic')
        setState(AI_STATE_ALERT, null, 'tears you away in panic. That hurt.');
      else if (src == 'berserk')
        setState(AI_STATE_ALERT, null, ' furiously tears you away. That hurt a lot.');
      else if (src == 'preservator')
        setState(AI_STATE_PRESERVED, null, 'stands still motionlessly.');
      else if (src == 'memories')
        setState(AI_STATE_POST_DETACH_MEMORIES, null,
          'feels unsure about their surroundings.');
      entity.setMask(-1);
    }

// event: on receiving effect
  public inline function onEffect(effect: _AIEffect)
    {
      effects.add(effect);

      updateEntity(); // update entity graphics
    }

// increase parasite affinity (never goes down)
  public function gainAffinity(amount: Int)
    {
      // wait until timeline is enabled
      if (!game.player.vars.timelineEnabled)
        return;
      var old = affinity;
      affinity += amount;
      if (affinity > 100)
        affinity = 100;
      if (old < 75 && affinity >= 75)
        {
          game.log(Const.hl('You feel you are deepening the affinity with this host.'), COLOR_SYMBIOSIS);
          game.goals.complete(GOAL_TUTORIAL_AFFINITY);
          if (game.player.chat.difficulty == UNSET)
            game.ui.event({
              type: UIEVENT_STATE,
              state: UISTATE_DIFFICULTY,
              obj: 'chat'
            });
          game.profile.addPediaArticle('hostAffinity');
          game.profile.addPediaArticle('hostConversation');
        }
      else if (old < 100 && affinity >= 100)
        {
          game.log(Const.hl('You have reached the full affinity with this host.'), COLOR_SYMBIOSIS);
          game.goals.complete(GOAL_TUTORIAL_MAX_AFFINITY);
        }
    }

// updates this ai with npc data (and vice versa)
  public function setNPC(npc: scenario.NPC)
    {
      npc.ai = this;
      this.eventID = (npc.event != null ? npc.event.id : null);
      this.job = npc.job;
      this.npcID = npc.id;
      this.name.real = npc.name;
      this.name.realCapped = npc.name;
      this.isMale = npc.isMale;
      this.isNameKnown = true;
      this.isJobKnown = true;
      this.isNPC = true;
      this.updateTile(npc.tileAtlasX, npc.tileAtlasY);
      this.entity.setNPC();
    }

// returns true if this AI has NPC clues or chat clues
  public function hasClues(): Bool
    {
      // npc clues
      if (isNPC && !npc.memoryKnown)
        return true;
      // chat clues
      if (chat.clues > 0)
        return true;
      return false;
    }

// returns true if this AI is from the group
  public inline function isGroup(): Bool
    {
      return (isTeamMember || type == 'blackops');
    }

// set this AI as a cultist
  public function setCult(cult: Cult)
    {
      isCultist = true;
      cultID = cult.id;
    }

// event hook: on state change
  dynamic function onStateChange()
    {}

// event hook: on being attacked
  public dynamic function onAttack()
    {}

// event hook: when invaded
  public dynamic function onInvade()
    {}

// event hook: on brain probe
  public dynamic function onBrainProbe()
    {}

// event hook: on despawning live AI
  public dynamic function onRemove()
    {}

// event hook: on AI death
// NOTE: called after the AI is removed from the area list!
  public dynamic function onDeath()
    {}

// event hook: on being noticed by player
  public dynamic function onNotice()
    {}

// event hook: pre-attach check
// NOTE: returns true if attachment is allowed
  public dynamic function attachPre(): Bool
    { return true; }

// hook: ai-specific bonus actions
  public dynamic function updateActionList()
    {}

// hook: run action
  public dynamic function action(action: _PlayerAction)
    {}

// ======================================================================


// log according to gender
  public function log(s: String, ?col: _TextColor = null)
    {
      if (!isMale)
        {
          s = StringTools.replace(s, 'He ', 'She ');
          s = StringTools.replace(s, ' he ', ' she ');
          s = StringTools.replace(s, ' him', ' her');
          s = StringTools.replace(s, ' his', ' her');
        }
      game.log(TheName() + ' ' + s, col);
    }

  public function toString()
    {
      return getName() + ' id:' + id + ' (' + x + ',' + y + '): ' + type + ', ' + job;
    }

// has seen object?
  public inline function hasSeenObject(id: Int): Bool
    {
      return Lambda.has(_objectsSeen, id);
    }

// marks object as seen
  public inline function objectSeen(id: Int)
    {
      _objectsSeen.add(id);
    }

// ========================== SETTERS ====================================

  function get_event(): scenario.Event
    {
      if (eventID == null)
        return null;
      else return game.timeline.getEvent(eventID);
    }

  function get_npc(): scenario.NPC
    {
      if (npcID < 0 || !isNPC)
        return null;
      return event.getNPC(npcID);
    }

  function set_alertness(v: Int)
    { return alertness = Const.clamp(v, 0, 100); }

  function get_maxOrgans()
    {
      // CON human: 4-8, dog: 2-6
      // BASE human: 2-4, dog: 1-3
      // ASSIM human: 4-6, dog: 3-5
      var x = Std.int(constitution / 2);
      return (x > 0 ? x : 1) + (hasTrait(TRAIT_ASSIMILATED) ? 2 : 0);
    }
  function get_maxItems()
    {
      // STR human: 4-8
      // BASE human: 6-10
      // ASSIM human: 8-12
      return strength + 2 + (hasTrait(TRAIT_ASSIMILATED) ? 2 : 0);
    }

// =================================================================================
  // AI view and hear distance
  // recalculated in GameScene.begin() at game start
  public static var VIEW_DISTANCE = 10;
  public static var HEAR_DISTANCE = 15;

  // number of turns AI stays alerted
  public static var ALERTED_TIMER = 10;

  // number of turns AI will stay spawned when invisible to player
  public static var DESPAWN_TIMER = 5;
}

@:structInit
class _AITimers extends _SaveObject
{
  public var alert: Int; // alerted, count down until AI calms down
    // alerted and player not visible, count down
//    alertPlayerNotVisible: Int,

  public function new(alert: Int)
    {
      this.alert = alert;
    }
}

// valid reasons for AI to change state
// NOTE: used in save games, cannot move out
enum _AIStateChangeReason
{
  REASON_NONE;
  REASON_BODY;
  REASON_BODY_SILENT;
  REASON_BACKUP;
  REASON_ATTACH;
  REASON_DETACH;
  REASON_HOST;
  REASON_PARASITE;
  REASON_DAMAGE;
  REASON_WITNESS;
}
